### 函数
#### 函数声明的组成要件

|组成|说明|
|------|------|
|返回类型|可以是`void`可以是前置或者后置形式，必选|
|`inline`|表示一种愿望，通过内联函数体实现函数调用|
|`constexpr`|表示当给定常量表达式作为实参时，应该可以在编译时对函数求值|
|`noexcept`|表示该函数不允许抛出异常|
|`[[noreturn]]`|表示该函数不会用常规的调用`/`返回机制返回结果|
|`virtual`|表示该函数可以被派生类覆盖|
|`override`|表示该函数必须覆盖基类中的一个虚函数|
|`final`|表示该函数不能被派生类覆盖|
|`static`|表示该函数不与某一特定的对象内联|
|`const`|表示该函数不能修改其对象的内容|

#### 返回值

```
string to_string(int a);//前置返回类型
auto to_string(int a) ->string//后置返回类型
```
+ 前置的`auto`关键字表示函数的返回类型放在参数列表之后，后置返回类型由符号`->`引导；
#### 函数指针

```
void error(string s){}
void (*efct)(string);//指向函数的指针，该函数接受一个字符串参数，不返回任何东西
void f(){
       efct = &error;//efct指向error
       efct("error");//通过efct调用error
}

void (*f1)(string) = &error;//等价于=error
void (*f2)(string) = error;//等价于=&error
void g(){
       f1("hello");//等价于(*f1)("hello")
       (*f1)("hello");//等价于f1("hello")
}
```

+ 可以将指向`noexcept`函数的指针声明成`noexcept`；别名`using`声明时不能使用`extern`和`unexcept`关键字；

```
void f(int) noexcept;
void g(int);
void (*p1)(int) = f;//正确，但是丢失了有用信息
void (*p1)(int) noexcept = f;//正确，保留了noexcept信息
void (*p1)(int) noexcept = g;//错误，不知道g不会抛出异常
```

#### inline函数
+ C++提供一种提高效率的方法，即在编译时将所调用函数的代码直接嵌入到主调函数中，而不是将流程转出去，这种嵌入到主调函数中的函数称为`内置函数`，又称为`内嵌函数`，或者`内联函数`；指定内置函数的方法只需要在函数首行的左端加一个`inline`关键字即可；可以在声明函数和定义函数时同时写`inline`，也可以只在函数声明时加`inline`，而定义函数时不加`inline`；

```
inline int fac(int n);//声明内置函数
inline int fac(int n){//定义内置函数
       return (n < 2) ? 1 : n*fac(n - 1);
}
```

+ `inline`限定符告诉编译器，它应该尝试为`fac()`的调用生成内联代码，而不是先为`fac()`函数构建代码再通过常规的调用机制调用它；归纳起来，只有那些规模小而又被频繁调用的简单函数，才适合于声明为`inline`函数；

#### constexpr函数

```
constexpr int fac(int n){
       return (n > 1) ? n*fac(n -1) : 1;
}
constexpr int f9 = fac(9);//必须在编译时求值
```

+ 当`constexpr`出现在函数定义中时，它的含义是如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中，而当`constexpr`出现在对象定义中时，它的含义是在编译时对初始化器求值；`constexpr`函数不能返回`void`类型；

#### [[noreturn]]函数

+ 形如`[[......]]`的概念被称为属性，属性可以置于C++语法的任何位置，把`[[noreturn]]`放在函数声明语句的开始位置表示不希望该函数返回任何结果，如`[[noreturn]] void exit(int)`该函数不会返回任何结果；如果函数被设置为`[[noreturn]]`但是在该函数的内部仍然返回了某个值，将产生未定义的行为；

#### 有默认参数的函数

+ 指定默认值的参数必须放在形参列表中的最右端，否则出错；在声明函数时指定默认值，而不能只在定义函数时制定默认值；

```
float area(float r = 6.5);//指定r的默认值是6.5
area();//相当于area(6.5)
area(7.5);//形参得到的是7.5而不是6.5
float volumn(float h , float r = 12.5);//只对形参r指定默认值12.5
volumn(45.6);//相当于volumn(45.6 , 12.5)
volumn(34.2 , 10.4);h的值为34.2，r的值为10.4
```

#### 函数模版

+ C++提供了函数模版，所谓函数模版，实际上是建立一个通用函数，其函数类型和参数类型不具体指定，用一个虚拟的类型来代表，这个通用函数就称为函数模版；

```
template<typename T>//模版声明，其中T为类型参数 也可以使用template <class T>
T max(T a , T b , T c){//定义一个通用函数，用T作虚拟的类型名
       if(b > a)
              a = b;
       if(c > a)
              a = c;
       return a;
}

//使用模版函数
int i1 = 123, i2 = 234,i3 = 567;
i = max(i1 , i2 , i3);
```

#### 变量的存储类别
#### 动态存储方式和静态存储方式
+ 所谓静态存储方式是指在程序运行期间，系统对变量分配固定的存储空间，而动态变存储方式则是在程序运行期间，系统对变量动态的分配存储空间；全局变量全部存放在静态存储区中，在程序开始执行时给全局变量分配存储单元，程序执行完毕就释放这些空间，在程序执行过程中它们占据固定的存储单元，而不是动态的进行分配和释放；在动态存储区中存放以下数据：`函数形式参数`，在调用函数时给形参分配存储空间；`函数中定义的变量`(未加static声明的局部变量)；`函数调用时的现场保护和返回地址等`；

|变量|说明|
|------|------|
|自动变量|函数中的局部变量，如果不用关键字`static`加以声明，编译系统对它们是动态的分配存储空间；自动变量用关键字`auto`或者省略作声明，如`auto int b;`|
|用static声明静态局部变量|有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次该函数调用时，该变量保留上一次函数调用结束时的值，这时就应该指定该局部变量为静态局部变量；对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值了，以后每次调用函数时不再重新赋初值而只是保留上一次函数调用结束时的值|
|用register声明寄存器变量|寄存器变量用关键字`register`声明，`register int i;`|
|用extern声明外部变量|全局变量是在函数的外部定义的，它的作用于为从变量的定义处开始，到本程序文件的末尾，编译时将全局变量分配到静态存储区；有时需要用`extern`来声明全局变量，以扩展全局变量的作用域；一、在一个文件内声明全局变量，如果外部变量不在文件的开头定义，其有效的作用范围只限于定义的位置到文件末尾为止，如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字`extern`对该变量做外部变量声明；`void main(){extern int a , b;//对全局变量a b做提前引用声明} int a = 15 , b = 16;//定义全局变量a b`；二、在多文件的程序中声明外部变量，如果一个程序包括两个文件，在两个文件中都要用到同一个外部变量num，不能分别在两个文件中各自定义一个外部变量num，否则在进程程序的链接时会出现`重复定义`的错误，正确的做法是：在任一个文件中定义外部变量num，而在另一个文件中用`extern`对`num`做外部变量声明`extern int num`；`//文件一：extern int a , b;//就可以使用了int main(){.......}  //文件二：int a = 3 , b = 4;`|
|用static声明静态外部变量|有时在程序设计中希望某些外部变量只限于被本文件引用，而不能被其他文件引用，这时可以在定义外部变量时加一个`static`声明；需要指出，加不加`static`声明的外部变量都用静态存储方式，只是作用范围不同而已，都是在编译时分配内存的|

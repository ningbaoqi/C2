### 引用
+ 指针的用法`*p和p->m`分别取代了`obj和ojb.m`；同一个指针在不同时刻可以指向不同对象，使用指针要比直接使用对象更小心，指针的值可能是`nullptr`，也可能指向一个我们并不需要的对象；`引用`作为对象的`别名`存放的也是对象的机器地址，访问引用与访问对象本身从语法形式上看是一样的，`引用`所引的永远是一开始初始化的那个对象，不存在空引用，我们可以认为引用一定对应着某个对象，引用最重要的用途是作为函数的实参或返回值；对一个数据可以建立一个`引用`，它的作用是`为一个变量起一个别名`，这是C++对C的一个重要扩展，`int a ;//定义a是整型变量；int &b = a;//声明b是a的引用`；经过这样的声明后，使用`a`和`b`的作用相同都代表同一个变量，声明变量`b`为`引用`，并不需要另外开辟内存单元来存放`b`的值，`b`和`a`占内存中的同一个存储单元，它们具有同一地址；

```
template<class T>
class vector{
       T* elem;
       public:
              T& operator[](int i){return elem[i];}//返回元素的引用
              const T& operator[](int i) const {return elem[i];}//返回常量元素的引用
              void push_back(const T& a);//通过引用传入待添加的元素
}

void f(const vector<double>& v){
       double d1 = v[1];//把v.operator[](1)索引的double的值拷贝给d1
       v[2] = 7;//把7赋值给v.operator[](2);索引的double
       v.push_back(d1);//给push_back()传入d1的引用
}
```
#### 左值引用

+ 符号`X&`的意思是`X`的引用，它经常用于表示`左值`的引用，因此成为`左值引用`；必须初始化引用；引用本身的值一旦经过初始化就不能再改变了，它永远都指向一开始指定的对象；

```
void f(){
       int val = 1;
       int& r {val};//r和val对应同一个int
       int x = r;//x的值变成了1
       
       int& r2;//错误，没有初始化
       extern int& r3;//正确，r3在别处初始化
    
       int val = 0;
       int& rr {var};
       ++rr;//val的值加1
       int* pp = &rr;//pp指向val
}
```
#### 右值引用

+ 声明符`&&`表示`右值引用`；

```
string& r1 {f()};//左值引用，错误f()是右值
string& r2 {"bob"};//左值引用，错误不允许绑定到临时变量
string&& rr1 {f()};//右值引用，正确
string&& rr2 {var};//右值引用，错误var是左值
string&& rr3 {"bob"};//rr3引用的是一个临时变量，它的内容是bob
```
#### 引用的引用
+ 如果你让引用指向某类型的引用，那么你得到的还是该类型的引用，而不是特殊的引用的引用类型；
